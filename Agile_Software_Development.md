
# Agile Software Development


[Coursera Link](https://www.coursera.org/learn/agile-software-development/lecture/i1Psj/welcome-and-course-intro)

---
## Introduction

We can compare Software development with **building a house**.
1. The buyer of the house **specifies their needs** (3 bedrooms, 4 bathrooms, pool, etc.)
2. Based on their needs, the builder is going to come with a **Home Layout Design** (Which de buyer may do some adjustments).
3. Then, the builder is going to make the **home detail design**, which contains the foundations (where the electricity is going to be, the plug distribution, etc.)
4. Start **building** the home.
    - As they are building it, they are going to call the **inspection** people inspect the house when some section is finished (electricity, windows, bedrooms, etc.)
    - Once that is done, the buyer will **approve** everything
5. The buyer will start **Living** in the house
6. The **Maintenance** starts.

In **Software Development**, the **1** are the requirements (what exactly do you need to build). The **2 and 3** are the Design of the entire software (Architecture, High and low level design). The **4** is the actual development, is where the developers start coding. Inside this part, there will be unit testing, which will test each new implementation. The **5** is when the production starts. The buyer will start using the software. Finally, the **6** is the operations and maintenance.
&nbsp;
<img src="./images/ASD1.png" alt="alt text" width="1000"/>
&nbsp;
This method is called ***waterfall*** method. In here you go from phase to phase. This was a very famous method, but it has a lot of **issues**. When time is passing, the requirements may change, and the market may vary, so it was not as efficient.

Because of this, it came the ***Agile*** Mindset (NOT a method).
The basic idea of this, is that instead of make a big cycle, create a lot of **small cycles**, so you define little, you build, you test, and again and again.

 &nbsp;
  &nbsp;
### Models

There are different models to develop software, which one of them may fit in a particular project.

You can **classify** these methods in different sections.
1. **Predictive vs Adaptive**
    - The **predictive** classification is when the customer knows EXACTLY what he wants to build. In here the cycle is straight. (Design -> Implementation -> Testing). You get the product in one shot, and because the requirements are known in the beginning, there are **NO Changes** during development.
    - The **adaptive** models are useful when the customer does not know exactly whet he wants to build. It has an **idea, but not everything**. So in here, they start with an idea. They develop a small version of it, they five it to the customer to have some feedback for the next **update**. In the end, the final product s not what the user **initially expected**, but it is what he really needed.
 &nbsp;
  <img src="./images/ASD2.png" alt="alt text" width="1000"/>

2. **Incremental vs Iterative**
   - The **incremental** models you have a fairly good idea of what you want to build, but instead of building it in one shot, you buid in increments. So, if you build a car, you first create the wheels, then the chassis, then the the top, etc.
   - The **iterative** models the costumer does not have a specific idea of what to build, but knows the purpose. So, if the goal is to go from point A to B, you first create a bicycle, then a motorcycle, then a car, and finally a truck. 
   - So the **Main differences** is that in the incremental model you break the product into smaller pieces, while the iterative you build something in top of the past development cycle.
  &nbsp;
    <img src="./images/ASD3.png" alt="alt text" width="1000"/>
---


## Common Terms

### User Stories
- These are a **basic unit of user needs**, which is also known as **requirements** 



---